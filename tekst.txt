się i oraz nigdy dlaczego
i oraz nigdy dlaczego
Plik źródłowy stanowi pewnego rodzaju hierarchię, a nie szablon. Znajdują się w nim informacje odnoszące się do pliku jako całościozwala to szybko przeska- kiwać zakresy, takie jak implementacje instrukcji if lub while, które nie odnoszą się do bieżącej sytuacji. Od lewej strony programiści szukają deklaracji metod, nowych zmiennych, a nawet nowych klas. Bez wcięć programy byłyby niemal nieczytelne dla ludzi.

Łamanie wcięć. Czasami kuszące jest łamanie zasad wcięć w przypadku krótkich instrukcji if, krótkich pętli while lub krótkich funkcji. Wszędzie tam, gdzie uległem tej pokusie, niemal zawsze wracałem i dodawałem właściwe wcięcia. Dlatego należy unikać łączenia zakresów w jeden wiersz, tak jak w poniższym przykładzie:
Czasami treść instrukcji while lub for nie zawiera kodu, tak jak jest to pokazane poniżej. Nie lubię tego typu struktur i staram się ich unikać. Gdy nie mogę ich uniknąć, upewniam się, że pusta treść jest prawidłowo wcięta i otoczona klamrami. Nie zliczę, ile razy dałem się oszukać przez średnik siedzący cichutko na końcu pętli while w tym samym wierszu. Jeżeli nie zapewnimy, że średnik ten bę- dzie widoczny, przez zastosowanie wcięcia w jego własnym wierszu, trudno będzie go zauważyć.
Zespół programistów powinien ustalić jeden styl formatowania, a następnie każdy członek zespołu powinien stosować ten styl. Oczekujemy, że program będzie miał jednorodny styl. Nie chcemy, aby wyglądał, jakby był napisany przez bandę niezgadzających się ze sobą indywiduów.
Gdy w roku 2002 zacząłem pracę nad projektem FitNesse, usiadłem z zespołem w celu wypraco- wania stylu kodowania. Zajęło to około 10 minut. Zdecydowaliśmy, gdzie będziemy umieszczać klamry, jaka powinna być wielkość wcięcia, jak będziemy nazywać klasy, zmienne, metody i tak dalej. Następnie wpisaliśmy te zasady w formater kodu naszego IDE i od tego momentu je stoso- waliśmy. Nie były to zasady, które preferuję; były to zasady, o których zdecydował zespół. Jako członek zespołu stosowałem je przy pisaniu kodu w projekcie FitNesse.
Należy pamiętać, że dobre oprogramowanie składa się ze zbioru dokumentów, które dobrze się czyta. Muszą mieć one spójny i gładki styl. Muszą budzić zaufanie czytelnika, który uzna, że for- matowanie, jakie zobaczy w jednym pliku źródłowym, będzie znaczyło to samo w innym. Ostatnią rzeczą, jaką chcemy zrobić, jest zwiększenie skomplikowania kodu przez jego pisanie przy użyciu kilku różnych odrębnych stylów.
Najlepsze w kodzie z listingu 6.2 jest to, że nie ma sposobu na stwierdzenie, czy implementacja ko- rzysta ze współrzędnych prostokątnych, czy kątowych. Być może całkowicie innych? A jednak in- terfejs niezawodnie reprezentuje strukturę danych.
Co lepsze, reprezentuje więcej niż tylko strukturę danych. Metody pozwalają na wymuszenie zasad dostępu. Można niezależnie odczytywać poszczególne współrzędne, ale ustawianie współrzędnych musi być wykonywane jako atomowa (tzn. pojedyncza) operacja.
Z drugiej strony, na listingu 6.1 jest bardzo wyraziście zaimplementowana klasa współrzędnych prostokątnych, która zmusza nas do niezależnego manipulowania tymi współrzędnymi. Powo- duje to ujawnienie implementacji. W rzeczywistości implementacja ta byłaby również ujawniona, jeżeli zmienne byłyby prywatne i używalibyśmy setterów i getterów poszczególnych zmiennych.
Ukrywanie implementacji nie sprowadza się do dodawania warstwy funkcji nad zmiennymi. Ukrywanie implementacji polega na tworzeniu abstrakcji! Klasa nie powinna po prostu przepychać zmiennych przez gettery i settery. Zamiast tego powinna udostępniać interfejs pozwalający użyt- kownikom na manipulowanie istotą danych bez konieczności znajomości jej implementacji.
Spójrzmy na listingi 6.3 i 6.4. W pierwszym użyte są konkretne terminy informujące o poziomie paliwa w pojeździe, natomiast w drugim użyta jest abstrakcja poziomu procentowego. W konkret- nym przypadku możemy być niemal pewni, że są to po prostu akcesory zmiennych. W przypad- ku abstrakcyjnym nie mamy pojęcia o formie danych.
Poniższe dwa przykłady pokazują różnice pomiędzy obiektami i strukturami danych. Obiekty ukrywają dane, tworząc abstrakcje, i udostępniają funkcje operujące na tych danych. Struktury danych udostępniają ich dane i nie mają znaczących funkcji. Przeczytajmy to jeszcze raz. Zwróćmy uwagę na komplementarną naturę tych dwóch definicji. Są one właściwie swoimi przeciwieństwa- mi. Różnica ta może wydawać się nieznaczna, ale ma daleko idące implikacje.
Jako przykład weźmy proceduralny kod kształtu z listingu 6.5. Klasa Geometry operuje na trzech klasach kształtu. Klasy kształtów są prostymi strukturami danych bez własnych operacji. Wszystkie operacje są zdefiniowane w klasie Geometry.
Czytelnicy, którzy preferują programowanie zorientowane obiektowo, mogą zmarszczyć brwi i na- rzekać, że jest to kod proceduralny — i będą mieli rację. Jednak to szyderstwo może być nie na miej- scu. Zwróćmy uwagę, co się stanie, jeżeli dodamy funkcję perimeter() do klasy Geometry. Klasy kształtów pozostaną bez zmian! Wszystkie inne klasy korzystające z klas kształtów również się nie zmienią! Z drugiej strony, jeżeli dodamy nowy kształt, musimy zmienić wszystkie operujące na nim funkcje z Geometry. Przeczytajmy to ponownie. Trzeba zwrócić uwagę, że te dwa warunki są zupełnie przeciwstawne.
Weźmy teraz przykład obiektowy z listingu 6.6. Metoda area() jest tu polimorficzna. Nie jest po- trzebna klasa Geometry. Jeżeli więc dodamy nowy kształt, żadna z istniejących funkcji nie ulegnie zmianie, ale jeżeli dodamy nową funkcję, wszystkie kształty będą musiały być zmienione1!